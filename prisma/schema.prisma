// RPG Platform - Universal Multi-System Schema
// Architecture: Dynamic schema where each RPG system defines its own
// attributes, skills, items, spells etc. as JSON structure.
// Player sheets are instances of that dynamic schema.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================================
// USERS & AUTH
// ============================================================

model User {
  id           String   @id @default(uuid())
  username     String   @unique
  email        String?  @unique
  passwordHash String
  role         UserRole @default(PLAYER)
  avatar       String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  ownedCampaigns Campaign[]    @relation("CampaignOwner")
  campaignMembers CampaignMember[]
  characters     Character[]
  diceRolls      DiceRoll[]

  @@map("users")
}

enum UserRole {
  ADMIN
  GM
  PLAYER
}

// ============================================================
// RPG SYSTEMS (the "engine" - can be imported from PDF)
// ============================================================

model RpgSystem {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?
  version     String   @default("1.0")
  coverImage  String?
  // JSON defining the entire system structure:
  // attributes, skills, derived stats, item categories etc.
  schema      Json
  // Static data: origins, rituals, weapons, spells, effects etc.
  // Each key is a data category (e.g. "origins", "rituals")
  data        Json     @default("{}")
  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  campaigns  Campaign[]
  characters Character[]

  @@map("rpg_systems")
}

// ============================================================
// CAMPAIGNS
// ============================================================

model Campaign {
  id          String         @id @default(uuid())
  name        String
  description String?
  coverImage  String?
  status      CampaignStatus @default(ACTIVE)
  inviteCode  String         @unique @default(uuid())
  settings    Json           @default("{}")
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  ownerId   String
  owner     User      @relation("CampaignOwner", fields: [ownerId], references: [id])
  systemId  String
  system    RpgSystem @relation(fields: [systemId], references: [id])

  members    CampaignMember[]
  characters Character[]
  notes      Note[]
  diceRolls  DiceRoll[]

  @@map("campaigns")
}

enum CampaignStatus {
  ACTIVE
  PAUSED
  FINISHED
  ARCHIVED
}

model CampaignMember {
  id         String             @id @default(uuid())
  role       CampaignMemberRole @default(PLAYER)
  joinedAt   DateTime           @default(now())

  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([campaignId, userId])
  @@map("campaign_members")
}

enum CampaignMemberRole {
  GM
  PLAYER
  SPECTATOR
}

// ============================================================
// CHARACTERS / SHEETS
// ============================================================

model Character {
  id          String        @id @default(uuid())
  name        String
  portrait    String?
  status      CharacterStatus @default(ACTIVE)
  isNPC       Boolean       @default(false)
  isPublic    Boolean       @default(false)  // GM can make visible to all players
  // The actual sheet data - filled values matching the system schema
  sheetData   Json          @default("{}")
  // Extra free-form notes
  notes       String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  ownerId    String
  owner      User      @relation(fields: [ownerId], references: [id])
  systemId   String
  system     RpgSystem @relation(fields: [systemId], references: [id])
  campaignId String?
  campaign   Campaign? @relation(fields: [campaignId], references: [id])

  diceRolls  DiceRoll[]
  conditions CharacterCondition[]

  @@map("characters")
}

enum CharacterStatus {
  ACTIVE
  INACTIVE
  DEAD
}

model CharacterCondition {
  id          String   @id @default(uuid())
  name        String
  description String?
  iconName    String?
  appliedAt   DateTime @default(now())

  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@map("character_conditions")
}

// ============================================================
// DICE ROLLS (real-time log)
// ============================================================

model DiceRoll {
  id          String   @id @default(uuid())
  expression  String   // e.g. "2d6+3", "1d20"
  results     Json     // individual die results + total
  label       String?  // e.g. "Atletismo", "Ataque"
  isSecret    Boolean  @default(false)
  rolledAt    DateTime @default(now())

  userId      String
  user        User      @relation(fields: [userId], references: [id])
  characterId String?
  character   Character? @relation(fields: [characterId], references: [id])
  campaignId  String?
  campaign    Campaign?  @relation(fields: [campaignId], references: [id])

  @@map("dice_rolls")
}

// ============================================================
// GM NOTES
// ============================================================

model Note {
  id         String   @id @default(uuid())
  title      String
  content    String
  isPrivate  Boolean  @default(true)
  category   String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  campaignId String
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@map("notes")
}

// ============================================================
// PDF IMPORT JOBS
// ============================================================

model PdfImportJob {
  id         String      @id @default(uuid())
  filename   String
  status     ImportStatus @default(PENDING)
  progress   Int         @default(0)
  log        String?
  result     Json?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  @@map("pdf_import_jobs")
}

enum ImportStatus {
  PENDING
  PROCESSING
  DONE
  ERROR
}
